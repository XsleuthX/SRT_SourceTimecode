<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>SRT Timecode Recalculator (Frame + SRT + Text-safe)</title>
  <style>
    :root{
      --bg:#0b0f14; --panel:#101722; --panel2:#0f1620; --border:#243246;
      --text:#e6eefc; --muted:#98a6bd; --accent:#7aa7ff; --danger:#ff6b6b;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background:linear-gradient(180deg, #08101a, #070b10);
      color:var(--text);
    }
    header{
      padding:16px 18px; border-bottom:1px solid var(--border);
      background:rgba(16,23,34,.85); backdrop-filter: blur(8px);
      position:sticky; top:0; z-index:10;
    }
    header h1{margin:0; font-size:16px; font-weight:650}
    header p{margin:6px 0 0; color:var(--muted); font-size:12px; line-height:1.35}
    .wrap{padding:16px 18px; max-width:1400px; margin:0 auto;}
    .controls{
      display:grid;
      grid-template-columns: 1.2fr 1fr 1fr 1fr;
      gap:12px;
      padding:12px;
      border:1px solid var(--border);
      background:rgba(16,23,34,.7);
      border-radius:14px;
    }
    .field{display:flex; flex-direction:column; gap:6px;}
    label{font-size:12px; color:var(--muted)}
    input, select, button{
      border:1px solid var(--border);
      background:var(--panel2);
      color:var(--text);
      padding:10px 10px;
      border-radius:10px;
      font-size:13px;
      outline:none;
    }
    input::placeholder{color:#6f7f99}
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .btn{
      cursor:pointer;
      background:linear-gradient(180deg, rgba(122,167,255,.18), rgba(122,167,255,.08));
      border:1px solid rgba(122,167,255,.35);
      font-weight:650;
    }
    .btn:hover{filter:brightness(1.08)}
    .btn.secondary{
      background:rgba(255,255,255,.03);
      border:1px solid var(--border);
      font-weight:600;
    }
    .btn.danger{
      background:rgba(255,107,107,.08);
      border:1px solid rgba(255,107,107,.35);
    }
    .status{
      margin-top:10px;
      padding:10px 12px;
      border:1px solid var(--border);
      background:rgba(16,23,34,.55);
      border-radius:12px;
      color:var(--muted);
      font-size:12px;
      line-height:1.45;
      white-space:pre-wrap;
    }
    .panes{
      margin-top:14px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    .pane{
      border:1px solid var(--border);
      background:rgba(16,23,34,.55);
      border-radius:14px;
      overflow:hidden;
      display:flex;
      flex-direction:column;
      min-height:520px;
    }
    .paneHeader{
      padding:10px 12px;
      border-bottom:1px solid var(--border);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      background:rgba(15,22,32,.55);
    }
    .paneHeader .title{font-size:12px; color:var(--muted)}
    .paneHeader .tools{display:flex; gap:8px; align-items:center; flex-wrap:wrap;}
    .resizable{flex:1; resize: both; overflow: auto; min-height: 220px;}
    textarea{
      width:100%;
      height:100%;
      min-height:520px;
      padding:12px;
      border:0;
      outline:none;
      background:transparent;
      color:var(--text);
      font-size:13px;
      line-height:1.45;
      white-space:pre;
      resize:none;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    }
    .small{font-size:12px; color:var(--muted);}
    @media (max-width: 1100px){
      .controls{grid-template-columns: 1fr 1fr}
      .panes{grid-template-columns: 1fr}
      textarea{min-height:420px}
      .pane{min-height:420px}
    }
  </style>
</head>
<body>
<header>
  <h1>SRT Timecode Recalculator (works with text + frame timecodes)</h1>
  <p>
    Paste anything (labels, blank lines, subtitle text). The tool only changes lines containing time ranges like
    <b>00:42:50:03 --> 00:42:52:22</b> (HH:MM:SS:FF) or standard SRT <b>00:00:01,000 --> 00:00:02,000</b>.
    Everything else stays unchanged.
  </p>
</header>

<div class="wrap">
  <div class="controls">
    <div class="field">
      <label>Source video start timecode (where SRT zero / first cue should align)</label>
      <input id="sourceTC" placeholder="e.g. 10:51:54:18  or  10:51:54,720" value="10:51:54:18"/>
      <div class="small">Accepts HH:MM:SS:FF or HH:MM:SS;FF or HH:MM:SS,mmm / .mmm or HH:MM:SS</div>
    </div>

    <div class="field">
      <label>Mode</label>
      <select id="mode">
        <option value="zeroToSource" selected>Make 00:00:00,000 (or 00:00:00:00) become the source timecode</option>
        <option value="firstToSource">Make FIRST detected timecode start become the source timecode</option>
      </select>
      <div class="small">If your pasted excerpt starts mid-video, use “FIRST detected”.</div>
    </div>

    <div class="field">
      <label>FPS (used for HH:MM:SS:FF parsing/output)</label>
      <select id="fps">
        <option value="23.976">23.976</option>
        <option value="24">24</option>
        <option value="25" selected>25</option>
        <option value="29.97">29.97</option>
        <option value="30">30</option>
      </select>
      <div class="small">For 25fps: 1 frame = 40ms.</div>
    </div>

    <div class="field">
      <label>Options</label>
      <div class="row">
        <label style="display:flex;align-items:center;gap:8px;cursor:pointer;">
          <input type="checkbox" id="clampZero" checked />
          <span class="small">Clamp negatives to 00:00:00,000 / 00:00:00:00</span>
        </label>
      </div>
      <div class="row">
        <button class="btn" id="processBtn">Recalculate</button>
        <button class="btn secondary" id="swapBtn" title="Move output back to input">Output → Input</button>
        <button class="btn danger" id="clearBtn" title="Clear both boxes">Clear</button>
      </div>
    </div>
  </div>

  <div class="status" id="status">Ready.</div>

  <div class="panes">
    <div class="pane">
      <div class="paneHeader">
        <div class="title">Input</div>
        <div class="tools">
          <span class="small" id="inCount"></span>
        </div>
      </div>
      <div class="resizable">
        <textarea id="input" spellcheck="false" placeholder="Paste your timecodes + subtitle text here..."></textarea>
      </div>
    </div>

    <div class="pane">
      <div class="paneHeader">
        <div class="title">Output</div>
        <div class="tools">
          <button class="btn secondary" id="copyBtn">Copy</button>
          <button class="btn secondary" id="downloadBtn">Download .txt</button>
          <span class="small" id="outCount"></span>
        </div>
      </div>
      <div class="resizable">
        <textarea id="output" spellcheck="false" placeholder="Converted timecodes will appear here (text unchanged)..."></textarea>
      </div>
    </div>
  </div>
</div>

<script>
  const el = (id) => document.getElementById(id);

  // Parse time strings to milliseconds (Number, may be float due to fps conversion).
  // Supports:
  // - HH:MM:SS:FF or HH:MM:SS;FF
  // - HH:MM:SS,mmm or HH:MM:SS.mmm
  // - HH:MM:SS (assume ,000)
  // - MM:SS or MM:SS,mmm / .mmm (assume hour=0)
  function parseAnyTimeToMs(str, fps){
    if (!str) return null;
    const t = String(str).trim();
    const fpsNum = Number(fps);

    // Frame format: HH:MM:SS:FF or HH:MM:SS;FF
    let m = t.match(/^(\d{1,3}):(\d{1,2}):(\d{1,2})[:;](\d{1,3})$/);
    if (m){
      const hh = parseInt(m[1],10);
      const mm = parseInt(m[2],10);
      const ss = parseInt(m[3],10);
      const ff = parseInt(m[4],10);
      if (!Number.isFinite(fpsNum) || fpsNum <= 0) return null;
      const baseMs = (hh*3600 + mm*60 + ss) * 1000;
      const frameMs = ff * (1000 / fpsNum);
      return baseMs + frameMs;
    }

    // HH:MM:SS,mmm or HH:MM:SS.mmm
    m = t.match(/^(\d{1,3}):(\d{1,2}):(\d{1,2})([,.])(\d{1,6})$/);
    if (m){
      const hh = parseInt(m[1],10);
      const mm = parseInt(m[2],10);
      const ss = parseInt(m[3],10);
      let msStr = m[5];
      // Normalize to 3 digits (truncate/pad)
      if (msStr.length === 1) msStr = msStr + "00";
      else if (msStr.length === 2) msStr = msStr + "0";
      else if (msStr.length > 3) msStr = msStr.slice(0,3);
      const ms = parseInt(msStr,10);
      return (hh*3600 + mm*60 + ss) * 1000 + ms;
    }

    // HH:MM:SS
    m = t.match(/^(\d{1,3}):(\d{1,2}):(\d{1,2})$/);
    if (m){
      const hh = parseInt(m[1],10);
      const mm = parseInt(m[2],10);
      const ss = parseInt(m[3],10);
      return (hh*3600 + mm*60 + ss) * 1000;
    }

    // MM:SS,mmm or MM:SS.mmm
    m = t.match(/^(\d{1,2}):(\d{1,2})([,.])(\d{1,6})$/);
    if (m){
      const mm = parseInt(m[1],10);
      const ss = parseInt(m[2],10);
      let msStr = m[4];
      if (msStr.length === 1) msStr = msStr + "00";
      else if (msStr.length === 2) msStr = msStr + "0";
      else if (msStr.length > 3) msStr = msStr.slice(0,3);
      const ms = parseInt(msStr,10);
      return (mm*60 + ss) * 1000 + ms;
    }

    // MM:SS
    m = t.match(/^(\d{1,2}):(\d{1,2})$/);
    if (m){
      const mm = parseInt(m[1],10);
      const ss = parseInt(m[2],10);
      return (mm*60 + ss) * 1000;
    }

    return null;
  }

  function pad2(n){ return String(n).padStart(2,'0'); }
  function pad3(n){ return String(n).padStart(3,'0'); }

  function msToSrt(ms, decimalSep){
    if (!Number.isFinite(ms)) ms = 0;
    ms = Math.max(0, ms);
    ms = Math.round(ms);
    const h = Math.floor(ms / 3600000); ms %= 3600000;
    const m = Math.floor(ms / 60000); ms %= 60000;
    const s = Math.floor(ms / 1000);
    const mm = ms % 1000;
    const hh = String(h).padStart(2,'0');
    const sep = decimalSep || ',';
    return `${hh}:${pad2(m)}:${pad2(s)}${sep}${pad3(mm)}`;
  }

  function msToFrameTC(ms, fps, frameSep){
    const fpsNum = Number(fps);
    if (!Number.isFinite(ms)) ms = 0;
    ms = Math.max(0, ms);

    // Use ms-based breakup then compute frame from remainder
    let totalSeconds = Math.floor(ms / 1000);
    let remMs = ms - totalSeconds * 1000;
    let ff = Math.round(remMs * fpsNum / 1000);

    // Carry if rounding hits fps
    const fpsCarry = Math.floor(fpsNum + 1e-6) || 1;
    if (ff >= fpsCarry){
      totalSeconds += 1;
      ff = 0;
    }

    const hh = Math.floor(totalSeconds / 3600);
    totalSeconds %= 3600;
    const mm = Math.floor(totalSeconds / 60);
    const ss = totalSeconds % 60;

    const sep = frameSep || ':';
    return `${String(hh).padStart(2,'0')}:${pad2(mm)}:${pad2(ss)}${sep}${String(ff).padStart(2,'0')}`;
  }

  // Count time range lines
  function countRanges(text){
    const re = /(\d{1,3}:\d{1,2}:\d{1,2}(?:[:;]\d{1,3}|[,.]\d{1,6})|\d{1,2}:\d{1,2}(?:[,.]\d{1,6})?)\s*-->\s*(\d{1,3}:\d{1,2}:\d{1,2}(?:[:;]\d{1,3}|[,.]\d{1,6})|\d{1,2}:\d{1,2}(?:[,.]\d{1,6})?)/g;
    let c=0; while(re.exec(text)) c++;
    return c;
  }

  function recalc(){
    const input = el("input").value || "";
    const fps = el("fps").value;
    const mode = el("mode").value;
    const clampZero = el("clampZero").checked;

    el("inCount").textContent = input ? `${countRanges(input)} time range(s) detected` : "";

    const srcStr = el("sourceTC").value;
    const sourceMs = parseAnyTimeToMs(srcStr, fps);
    if (sourceMs === null){
      el("status").textContent = `❌ Could not parse source timecode: "${srcStr}".\nTry HH:MM:SS:FF or HH:MM:SS,mmm or HH:MM:SS.`;
      return;
    }

    // Regex captures:
    // 1) start time, 2) end time, 3) trailing settings (optional)
    const rangeRe = /(\d{1,3}:\d{1,2}:\d{1,2}(?:[:;]\d{1,3}|[,.]\d{1,6})|\d{1,2}:\d{1,2}(?:[,.]\d{1,6})?)\s*-->\s*(\d{1,3}:\d{1,2}:\d{1,2}(?:[:;]\d{1,3}|[,.]\d{1,6})|\d{1,2}:\d{1,2}(?:[,.]\d{1,6})?)([^\n\r]*)/g;

    // Find first start time if align-first
    let firstStartMs = 0;
    if (mode === "firstToSource"){
      const m = rangeRe.exec(input);
      rangeRe.lastIndex = 0; // reset
      if (!m){
        el("status").textContent = "❌ No time ranges found in input.";
        return;
      }
      firstStartMs = parseAnyTimeToMs(m[1], fps);
      if (firstStartMs === null){
        el("status").textContent = `❌ Could not parse first timecode: "${m[1]}".`;
        return;
      }
    }

    const offsetMs = (mode === "zeroToSource") ? sourceMs : (sourceMs - firstStartMs);

    let updated = 0;

    const out = input.replace(rangeRe, (full, startStr, endStr, tail) => {
      const aMs = parseAnyTimeToMs(startStr, fps);
      const bMs = parseAnyTimeToMs(endStr, fps);
      if (aMs === null || bMs === null) return full;

      let na = aMs + offsetMs;
      let nb = bMs + offsetMs;
      if (clampZero){
        na = Math.max(0, na);
        nb = Math.max(0, nb);
      }

      // Decide output format based on original startStr (prefer frame if it had :FF or ;FF)
      const isFrame = /[:;]\d{1,3}$/.test(startStr.trim()) || /[:;]\d{1,3}$/.test(endStr.trim());
      const frameSepMatch = startStr.includes(';') ? ';' : ':';
      const decSepMatch = startStr.includes('.') ? '.' : ','; // keep comma by default

      const newStart = isFrame ? msToFrameTC(na, fps, frameSepMatch) : msToSrt(na, decSepMatch);
      const newEnd   = isFrame ? msToFrameTC(nb, fps, frameSepMatch) : msToSrt(nb, decSepMatch);

      updated++;
      return `${newStart} --> ${newEnd}${tail || ""}`;
    });

    el("output").value = out;
    el("outCount").textContent = out ? `${countRanges(out)} time range(s) in output` : "";

    const sign = offsetMs >= 0 ? "+" : "-";
    const absOffset = Math.abs(offsetMs);
    const offsetPretty = msToSrt(absOffset, ',');

    const modeLabel = mode === "zeroToSource"
      ? `Mode: 00:00:00,000 / 00:00:00:00 → source (${srcStr})`
      : `Mode: FIRST timecode → source (${srcStr})`;

    el("status").textContent =
      `✅ Done.\n${modeLabel}\nOffset applied: ${sign}${offsetPretty} (fps=${fps})\nTime ranges updated: ${updated}`;
  }

  function copyOut(){
    const txt = el("output").value || "";
    if (!txt){
      el("status").textContent = "Nothing to copy (output is empty).";
      return;
    }
    navigator.clipboard.writeText(txt)
      .then(() => el("status").textContent = "✅ Copied output to clipboard.")
      .catch(() => el("status").textContent = "❌ Clipboard copy failed (browser permission).");
  }

  function downloadOut(){
    const txt = el("output").value || "";
    if (!txt){
      el("status").textContent = "Nothing to download (output is empty).";
      return;
    }
    const blob = new Blob([txt], {type:"text/plain;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "timecode_converted.txt";
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
    el("status").textContent = "✅ Download started: timecode_converted.txt";
  }

  function swapOutputToInput(){
    const out = el("output").value;
    if (!out){
      el("status").textContent = "Output is empty — nothing to move to input.";
      return;
    }
    el("input").value = out;
    el("status").textContent = "✅ Moved output back into input.";
    el("inCount").textContent = `${countRanges(out)} time range(s) detected`;
  }

  function clearAll(){
    el("input").value = "";
    el("output").value = "";
    el("inCount").textContent = "";
    el("outCount").textContent = "";
    el("status").textContent = "Cleared.";
  }

  el("processBtn").addEventListener("click", recalc);
  el("copyBtn").addEventListener("click", copyOut);
  el("downloadBtn").addEventListener("click", downloadOut);
  el("swapBtn").addEventListener("click", swapOutputToInput);
  el("clearBtn").addEventListener("click", clearAll);

  el("input").addEventListener("input", () => {
    const v = el("input").value || "";
    el("inCount").textContent = v ? `${countRanges(v)} time range(s) detected` : "";
  });

</script>
</body>
</html>
